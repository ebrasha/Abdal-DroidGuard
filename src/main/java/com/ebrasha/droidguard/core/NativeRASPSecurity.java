/*
 **********************************************************************
 * -------------------------------------------------------------------
 * Project Name : Abdal DroidGuard
 * File Name    : NativeRASPSecurity.java
 * Author       : Ebrahim Shafiei (EbraSha)
 * Email        : Prof.Shafiei@Gmail.com
 * Created On   : 2025-01-10 23:30:00
 * Description  : Native RASP Security with JNI for anti-hooking protection
 * -------------------------------------------------------------------
 *
 * "Coding is an engaging and beloved hobby for me. I passionately and insatiably pursue knowledge in cybersecurity and programming."
 * â€“ Ebrahim Shafiei
 *
 **********************************************************************
 */

package com.ebrasha.droidguard.core;

import com.ebrasha.droidguard.utils.SimpleLogger;
import java.io.*;
import java.nio.file.*;

/**
 * Native RASP Security - JNI wrapper for critical security checks
 * This class provides native-level protection against Frida hooking
 */
public class NativeRASPSecurity {
    
    private final SimpleLogger logger = SimpleLogger.getInstance();
    private static final String NATIVE_LIBRARY_NAME = "raspshield";
    private static final int EXPECTED_INTEGRITY_KEY = 0xABDA1D01; // Abdal DroidGuard Secret
    
    // Native method declarations
    public static native boolean isDebuggerPresentNative();
    public static native int checkNativeIntegrity();
    public static native boolean checkRootNative();
    public static native boolean checkHookNative();
    public static native boolean checkEmulatorNative();
    
    /**
     * Generate native RASP security code
     */
    public String generateNativeRASPSecurityCode() {
        StringBuilder code = new StringBuilder();
        
        code.append("/*\n");
        code.append(" * Native RASP Security Code\n");
        code.append(" * Generated by Abdal DroidGuard\n");
        code.append(" * Anti-hooking protection with JNI\n");
        code.append(" */\n");
        code.append("package com.ebrasha.abdal.rasp;\n\n");
        
        code.append("public class NativeRASPSecurity {\n");
        code.append("    \n");
        code.append("    private static final String NATIVE_LIBRARY_NAME = \"raspshield\";\n");
        code.append("    private static final int EXPECTED_INTEGRITY_KEY = 0xABDA1D01;\n");
        code.append("    \n");
        code.append("    static {\n");
        code.append("        try {\n");
        code.append("            System.loadLibrary(NATIVE_LIBRARY_NAME);\n");
        code.append("        } catch (UnsatisfiedLinkError e) {\n");
        code.append("            System.err.println(\"Abdal DroidGuard: ERROR! Could not load native library. Security features disabled.\");\n");
        code.append("        }\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    // Native method declarations\n");
        code.append("    public static native boolean isDebuggerPresentNative();\n");
        code.append("    public static native int checkNativeIntegrity();\n");
        code.append("    public static native boolean checkRootNative();\n");
        code.append("    public static native boolean checkHookNative();\n");
        code.append("    public static native boolean checkEmulatorNative();\n");
        code.append("    \n");
        code.append("    /**\n");
        code.append("     * Executes all critical native RASP checks\n");
        code.append("     */\n");
        code.append("    public static boolean performNativeChecks() {\n");
        code.append("        try {\n");
        code.append("            // 1. Check Anti-Debugging\n");
        code.append("            if (isDebuggerPresentNative()) {\n");
        code.append("                System.out.println(\"DroidGuard ALERT: Native Debugger Detected!\");\n");
        code.append("                return true;\n");
        code.append("            }\n");
        code.append("            \n");
        code.append("            // 2. Check Native Code Integrity\n");
        code.append("            int nativeKey = checkNativeIntegrity();\n");
        code.append("            if (nativeKey != EXPECTED_INTEGRITY_KEY) {\n");
        code.append("                System.out.println(\"DroidGuard ALERT: Native Integrity Check Failed! (Hooking suspected)\");\n");
        code.append("                return true;\n");
        code.append("            }\n");
        code.append("            \n");
        code.append("            // 3. Check Root Detection\n");
        code.append("            if (checkRootNative()) {\n");
        code.append("                System.out.println(\"DroidGuard ALERT: Root Detected!\");\n");
        code.append("                return true;\n");
        code.append("            }\n");
        code.append("            \n");
        code.append("            // 4. Check Hook Detection\n");
        code.append("            if (checkHookNative()) {\n");
        code.append("                System.out.println(\"DroidGuard ALERT: Hook Detected!\");\n");
        code.append("                return true;\n");
        code.append("            }\n");
        code.append("            \n");
        code.append("            // 5. Check Emulator Detection\n");
        code.append("            if (checkEmulatorNative()) {\n");
        code.append("                System.out.println(\"DroidGuard ALERT: Emulator Detected!\");\n");
        code.append("                return true;\n");
        code.append("            }\n");
        code.append("            \n");
        code.append("            return false; // All native checks passed\n");
        code.append("        } catch (Exception e) {\n");
        code.append("            // Error in native checks - assume security violation\n");
        code.append("            System.out.println(\"DroidGuard ALERT: Native Security Check Failed!\");\n");
        code.append("            return true;\n");
        code.append("        }\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    /**\n");
        code.append("     * Block execution if security violations detected\n");
        code.append("     */\n");
        code.append("    public static void blockIfSecurityViolation() {\n");
        code.append("        if (performNativeChecks()) {\n");
        code.append("            // Security violation detected - terminate immediately\n");
        code.append("            android.os.Process.killProcess(android.os.Process.myPid());\n");
        code.append("            System.exit(1);\n");
        code.append("        }\n");
        code.append("    }\n");
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Generate native C++ code for RASP shield
     */
    public String generateNativeCppCode() {
        StringBuilder code = new StringBuilder();
        
        code.append("/*\n");
        code.append(" * Abdal DroidGuard - Native RASP Shield\n");
        code.append(" * File: native-raspshield.cpp\n");
        code.append(" * Author: Ebrahim Shafiei (EbraSha)\n");
        code.append(" * Description: Advanced Anti-Debugging and Integrity Check in Native Code\n");
        code.append(" */\n\n");
        
        code.append("#include <jni.h>\n");
        code.append("#include <string>\n");
        code.append("#include <fstream>\n");
        code.append("#include <unistd.h>\n");
        code.append("#include <sys/ptrace.h>\n");
        code.append("#include <sys/wait.h>\n");
        code.append("#include <dirent.h>\n");
        code.append("#include <fcntl.h>\n\n");
        
        code.append("// Secret integrity key\n");
        code.append("const int SECRET_INTEGRITY_KEY = 0xABDA1D01;\n\n");
        
        code.append("// Anti-Debugging Check (TracerPid check)\n");
        code.append("extern \"C\" JNIEXPORT jboolean JNICALL\n");
        code.append("Java_com_ebrasha_abdal_rasp_NativeRASPSecurity_isDebuggerPresentNative(\n");
        code.append("        JNIEnv *env, jclass clazz) {\n");
        code.append("    \n");
        code.append("    char buf[1024];\n");
        code.append("    int fd = open(\"/proc/self/status\", O_RDONLY);\n");
        code.append("    if (fd == -1) {\n");
        code.append("        return JNI_FALSE;\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    ssize_t num_read = read(fd, buf, sizeof(buf) - 1);\n");
        code.append("    close(fd);\n");
        code.append("    \n");
        code.append("    if (num_read > 0) {\n");
        code.append("        buf[num_read] = '\\0';\n");
        code.append("        std::string status(buf);\n");
        code.append("        \n");
        code.append("        size_t tracer_pos = status.find(\"TracerPid:\");\n");
        code.append("        if (tracer_pos != std::string::npos) {\n");
        code.append("            size_t pid_start = tracer_pos + 10;\n");
        code.append("            while (pid_start < num_read && (buf[pid_start] == ' ' || buf[pid_start] == '\\t')) {\n");
        code.append("                pid_start++;\n");
        code.append("            }\n");
        code.append("            if (pid_start < num_read && buf[pid_start] != '0') {\n");
        code.append("                return JNI_TRUE;\n");
        code.append("            }\n");
        code.append("        }\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    return JNI_FALSE;\n");
        code.append("}\n\n");
        
        code.append("// Native Integrity Check\n");
        code.append("extern \"C\" JNIEXPORT jint JNICALL\n");
        code.append("Java_com_ebrasha_abdal_rasp_NativeRASPSecurity_checkNativeIntegrity(\n");
        code.append("        JNIEnv *env, jclass clazz) {\n");
        code.append("    return (jint)SECRET_INTEGRITY_KEY;\n");
        code.append("}\n\n");
        
        code.append("// Root Detection\n");
        code.append("extern \"C\" JNIEXPORT jboolean JNICALL\n");
        code.append("Java_com_ebrasha_abdal_rasp_NativeRASPSecurity_checkRootNative(\n");
        code.append("        JNIEnv *env, jclass clazz) {\n");
        code.append("    \n");
        code.append("    // Check for su binary\n");
        code.append("    if (access(\"/system/bin/su\", F_OK) == 0 || access(\"/system/xbin/su\", F_OK) == 0) {\n");
        code.append("        return JNI_TRUE;\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    // Check for SuperSU\n");
        code.append("    if (access(\"/system/app/SuperSU.apk\", F_OK) == 0) {\n");
        code.append("        return JNI_TRUE;\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    return JNI_FALSE;\n");
        code.append("}\n\n");
        
        code.append("// Hook Detection\n");
        code.append("extern \"C\" JNIEXPORT jboolean JNICALL\n");
        code.append("Java_com_ebrasha_abdal_rasp_NativeRASPSecurity_checkHookNative(\n");
        code.append("        JNIEnv *env, jclass clazz) {\n");
        code.append("    \n");
        code.append("    // Check for Xposed\n");
        code.append("    if (access(\"/system/framework/XposedBridge.jar\", F_OK) == 0) {\n");
        code.append("        return JNI_TRUE;\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    // Check for Frida\n");
        code.append("    if (access(\"/data/local/tmp/frida-server\", F_OK) == 0) {\n");
        code.append("        return JNI_TRUE;\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    return JNI_FALSE;\n");
        code.append("}\n\n");
        
        code.append("// Emulator Detection\n");
        code.append("extern \"C\" JNIEXPORT jboolean JNICALL\n");
        code.append("Java_com_ebrasha_abdal_rasp_NativeRASPSecurity_checkEmulatorNative(\n");
        code.append("        JNIEnv *env, jclass clazz) {\n");
        code.append("    \n");
        code.append("    // Check for emulator files\n");
        code.append("    if (access(\"/system/lib/libc_malloc_debug_qemu.so\", F_OK) == 0) {\n");
        code.append("        return JNI_TRUE;\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    // Check for Bluestacks\n");
        code.append("    if (access(\"/data/app/com.bluestacks.appmart\", F_OK) == 0) {\n");
        code.append("        return JNI_TRUE;\n");
        code.append("    }\n");
        code.append("    \n");
        code.append("    return JNI_FALSE;\n");
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Create native RASP security files
     */
    public void createNativeRASPSecurity(Path extractedDir) throws Exception {
        logger.info("Creating native RASP security with anti-hooking protection...");
        
        // Create Java interface
        String javaCode = generateNativeRASPSecurityCode();
        Path assetsDir = extractedDir.resolve("assets");
        Files.createDirectories(assetsDir);
        Path javaFile = assetsDir.resolve("NativeRASPSecurity.java");
        Files.write(javaFile, javaCode.getBytes("UTF-8"));
        
        // Create C++ source code
        String cppCode = generateNativeCppCode();
        Path cppFile = assetsDir.resolve("native-raspshield.cpp");
        Files.write(cppFile, cppCode.getBytes("UTF-8"));
        
        // Create native library placeholder
        createNativeLibraryPlaceholder(extractedDir);
        
        logger.info("Native RASP security created successfully");
    }
    
    /**
     * Create native library placeholder
     */
    private void createNativeLibraryPlaceholder(Path extractedDir) throws Exception {
        // Create lib directory
        Path libDir = extractedDir.resolve("lib");
        Files.createDirectories(libDir);
        
        // Create architecture-specific directories
        String[] architectures = {"arm64-v8a", "armeabi-v7a", "x86", "x86_64"};
        
        for (String arch : architectures) {
            Path archDir = libDir.resolve(arch);
            Files.createDirectories(archDir);
            
            // Create placeholder .so file
            Path soFile = archDir.resolve("lib" + NATIVE_LIBRARY_NAME + ".so");
            Files.write(soFile, "Native RASP Shield Library".getBytes("UTF-8"));
        }
        
        logger.info("Native library placeholders created for all architectures");
    }
}

